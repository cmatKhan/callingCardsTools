{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Reference Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#reference","text":"","title":"Reference"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"about/license/","text":"The MIT License (MIT) Copyright \u00a9 2022 Chase Mateusiak Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"about/license/#the-mit-license-mit","text":"Copyright \u00a9 2022 Chase Mateusiak Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"The MIT License (MIT)"},{"location":"bam_parser/BarcodeParser/","text":"Using a json which describes acceptable values for given barcodes, check the edit distance between the barcode components (substrings) and the Source code in callingcardstools/bam_parsers/BarcodeParser.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 class BarcodeParser : \"\"\"Using a json which describes acceptable values for given barcodes, check the edit distance between the barcode components (substrings) and the \"\"\" # set attributes key_dict = { \"indicies\" : \"indicies\" , \"components\" : \"components\" , \"insert_seq\" : \"insert_seq\" , \"tf_map\" : \"tf_map\" , \"tf_map_keys\" : { \"bc_components\" : \"bc_components\" , \"tf\" : \"tf\" }, # this is created from tf_map, which is provided in barcode_details \"tf_dict\" : \"tf_dict\" , \"match_allowance\" : \"match_allowance\" } barcode_dict = {} barcode_details_json = \"\" barcode = \"\" # constructor def __init__ ( self , barcode_details_json ): # set attributes self . barcode_details_json = barcode_details_json # set the initialized barcode details # note that this also sets the match allowances self . set_barcode_details ( barcode_details_json ) def set_barcode ( self , barcode ): \"\"\"setter for the barcode attribute. Note that the barcode is cast to upper Args: barcode (str): barcode to store in the barcode attribute \"\"\" self . barcode = barcode . upper () def set_barcode_details ( self , barcode_details_json ): \"\"\"parse the calling cards bed file name column into components and perform This expects a dataframe with AT LEAST the columns (there may be more): ['chrom','chromStart','chromEnd','barcode', 'strand', 'insert_seq'] :param bed_df: :param barcode_details: :param fltr_bed_output_name: \"\"\" # check barcode_details path for input_path in [ barcode_details_json ]: if not os . path . exists ( input_path ): raise FileNotFoundError ( f \"Input file DNE: { input_path } \" ) # open json, read in as dict with open ( barcode_details_json ) as f1 : barcode_dict = json . load ( f1 ) # verify format barcode_dict = self . verify_barcode_details ( barcode_dict ) # update self self . barcode_dict = barcode_dict self . set_component_match_allowances () self . barcode_details_json = barcode_details_json def verify_barcode_details ( self , barcode_dict ): \"\"\"Verify expectations on the barcode details Args: barcode_dict (dict): A barcode_details dictionary parsed from the barcode_details json file Raises: KeyError: Raised if an expected key in the barcode_details DNE ValueError: Raised if a value in a given field in the barcode_details does not match expectations Returns: (dict): The verified barcode_details dictionary \"\"\" # check that the indicies and components match if not list ( barcode_dict [ self . key_dict [ 'components' ]] . keys ()) . sort () == \\ list ( barcode_dict [ self . key_dict [ 'indicies' ]] . keys ()) . sort (): raise KeyError ( 'The keys in the barcode_component json and the ' + 'barcode_component_indicies json are not the same' ) # check that the components are the correct length according to the # indicies barcode_components_length_check_dict = { k : v [ 1 ] - v [ 0 ] for k , v in \\ barcode_dict [ 'indicies' ] . items ()} for k , v in barcode_dict [ 'components' ] . items (): for comp in v : if not len ( comp ) == barcode_components_length_check_dict [ k ]: raise ValueError ( f \"There exists a component in \" \\ f \"barcode_components which is not the length \" \\ f \"described by the barcode_details['indicies']: \" \\ f \" { comp } , { barcode_components_length_check_dict [ k ] } \" ) # if a tf_map dict exists, check that the bc_components and tf list # exist if self . key_dict [ 'tf_map' ] in barcode_dict : for bc_comp in barcode_dict [ self . key_dict [ 'tf_map' ]] \\ [ self . key_dict [ 'tf_map_keys' ][ 'bc_components' ]]: if bc_comp not in barcode_dict [ self . key_dict [ 'components' ]]: raise KeyError ( f \"tf barcode component { bc_comp } is not \" \\ f \"in barcode details { self . key_dict [ 'components' ] } \" ) # if the match_allowance field exists, check that the components match # those in the components field, and that the distance is an integer if self . key_dict [ 'match_allowance' ] in barcode_dict : for comp , dist in barcode_dict [ self . key_dict [ 'match_allowance' ]] . items (): if comp not in barcode_dict [ self . key_dict [ 'components' ]]: raise KeyError ( f \"The keys in \" \\ f \" { self . barcode_dict [ self . key_dict [ 'match_allowance' ]] } \" \\ f \"must be in { self . barcode_dict [ self . key_dict [ 'components' ]] } \" ) if not isinstance ( dist , int ) or dist < 0 : raise ValueError ( \"Match allowance must be a positive integer which \\ represents the maximum edit distance from the expected \\ barcode\" ) # cast all values in self.key_dict['components'] to upper # note that the barcode is also always cast to upper upper_components_dict = {} for k , seq_list in barcode_dict [ self . key_dict [ 'components' ]] . items (): upper_seq_list = [] for sequence in seq_list : upper_seq_list . append ( sequence . upper ()) upper_components_dict . setdefault ( k , upper_seq_list ) barcode_dict [ self . key_dict [ 'components' ]] = upper_components_dict # cast insert seq to upper if it exists if self . key_dict [ 'insert_seq' ] in barcode_dict : upper_insert_seq = [] for sequence in barcode_dict [ self . key_dict [ 'insert_seq' ]]: upper_insert_seq . append ( sequence . upper ()) barcode_dict [ self . key_dict [ 'insert_seq' ]] = upper_insert_seq # if tf_map exists, then set the tf_dict if self . key_dict [ 'tf_map' ] in barcode_dict : barcode_dict [ self . key_dict [ 'tf_dict' ]] = self . tf_dict ( barcode_dict ) return barcode_dict def set_component_match_allowances ( self ): \"\"\"update the barcode_dict attribute with match allowances for all components which are not already set in the barcode_details json\"\"\" # if the match_allowance field DNE, create one with an empty dict x = self . barcode_dict . setdefault ( self . key_dict [ 'match_allowance' ], {}) # for each key in the barcode_dict[comp], set to 0 if it does not # already exist for comp in self . barcode_dict [ self . key_dict [ 'components' ]]: x = self . barcode_dict [ self . key_dict [ 'match_allowance' ]] \\ . setdefault ( comp , 0 ) def component_edit_distance ( self ): \"\"\"Check the barcode against the expected values at each component substring location. Args: barcode (Str): A barcode string (the entire thing) Raises: AttributeError: Raised if self.barcode_dict is empty IndexError: Raised if the indices of a given component are out of bounds for the barcode input string Returns: Dict: A dictionary where the component names are keys and the values are the minimum edit distance between the barcode component substring and the values listed in the barcode_details json \"\"\" if self . barcode == \"\" : raise AttributeError ( \"No barcode set\" ) if not self . barcode_dict : raise AttributeError ( \"Barcode Dict is empty. Set a the barcode\" + \"dict by calling BarcodeChecker.set_barcode_details(json_path)\" ) # Using the keys of the barcode_components dict, make a dictionary # with structure {component1: \"TAG\", component2:\"TTAAGG\", ...} where the keys are # barcode components, and the values the substring of the barcode # which corresponds try : parsed_barcode_dict = \\ { k : self . barcode [ v [ 0 ]: v [ 1 ]] for k , v in self . barcode_dict [ 'indicies' ] . items ()} except IndexError as exc : raise f 'Barcode { self . barcode } does not have valid indicies for ' \\ f 'all expected barcode components. { exc } ' from exc # iterate over each part, return a dict in form {component: min_edit_dist} barcode_summary = { k : self . min_edit_dist ( k , v ) for k , v in parsed_barcode_dict . items ()} return barcode_summary def barcode_check ( self ): \"\"\"Determine if the barcode passes (True) or fails (False) given the edit distances between it and the expected components, and the allowable edit distance between a given component and the actual value. Args: component_edit_dist_dict (Dict): A dictionary where the keys are barcode components and the values are the minimum edit distance of a given barcode against the corresponding allowable components Returns: (Dict): A dict of structure {\"pass\": Boolean, True if the barcode passes, \"tf\": Str, where the value is eithe \"*\" if unknown or a TF string from the barcode_details} \"\"\" if self . barcode == \"\" : raise AttributeError ( \"No barcode set\" ) tf = self . get_tf () component_edit_dist_dict = self . component_edit_distance () try : false_count = sum ([ 0 if v <= \\ self . barcode_dict [ self . key_dict [ 'match_allowance' ]][ k ] else 1 \\ for k , v in component_edit_dist_dict . items ()]) except KeyError : KeyError ( \"A given component was not present in the component match dict\" ) bc_pass = True if false_count == 0 else False return ({ \"pass\" : bc_pass , \"tf\" : tf }) def min_edit_dist ( self , barcode_component , barcode_substr ): \"\"\"get the minimum levenshtein edit distance between a given barcode component and the allowable strings for that component Args: barcode_component (Str): Name of a given barcode component barcode_substr (Str): A substring of the read barcode to check against the the barcode_details['component'] list Raises: KeyError: Raised if the barcode_component does not exist in self.barcode_dict Returns: Int: The minimum distance between the barcode_substr and the values allowable for the barcode_component \"\"\" if barcode_component not in self . barcode_dict [ self . key_dict [ 'components' ]]: raise KeyError ( f \" { barcode_component } is not in \" \\ f \"the keys of the current barcode_details dict \" \\ f \" { self . barcode_details_json } \" ) min_dist = min ([ self . edit_dist ( barcode_substr , valid_component ) for \\ valid_component in self . barcode_dict [ self . key_dict [ 'components' ]][ barcode_component ]]) return min_dist def edit_dist ( self , s1 , s2 ): \"\"\"Calculate the levenshtein distance between two strings Cite: https://stackoverflow.com/a/32558749 Args: s1 (Str): One of two strings to match against the other s2 (Str): One of two strings to match against the other Returns: Int: A number where 0 >= n <= longer of the two strings \"\"\" if len ( s1 ) > len ( s2 ): s1 , s2 = s2 , s1 distances = range ( len ( s1 ) + 1 ) for i2 , c2 in enumerate ( s2 ): distances_ = [ i2 + 1 ] for i1 , c1 in enumerate ( s1 ): if c1 == c2 : distances_ . append ( distances [ i1 ]) else : distances_ . append ( 1 + min (( distances [ i1 ], distances [ i1 + 1 ], distances_ [ - 1 ]))) distances = distances_ return distances [ - 1 ] def get_insert_seqs ( self ): \"\"\"Getter for the insert seq sequence from the barcode details json Raises: AttributeError: Raised if the current barcode details json does not have an insert seq key Returns: Str: The insert seq string (upper case) from the barcode details \"\"\" if self . key_dict [ 'insert_seq' ] in self . barcode_dict : return self . barcode_dict [ self . key_dict [ 'insert_seq' ]] else : raise AttributeError ( f 'Current barcode details ' \\ f ' { self . barcode_details_json } does not have an ' \\ f 'insert seq component' ) def get_tf_barcode ( self ): \"\"\"If the tf_map attribute is set, use the tf_bc_components to get the string at the correct indicies in the input barcode. Args: barcode (Str): the barcode extracted from a given read Raises: KeyError: Raised if tf_map does not exist in self.barcode_dict Returns: Str: The substring of barcode at the indicies given in the tf_map.tf_bc_components \"\"\" if self . barcode == \"\" : raise AttributeError ( \"No barcode set\" ) if self . key_dict [ 'tf_map' ] not in self . barcode_dict . keys (): raise KeyError ( 'tf_map DNE' ) # extract the tf barcode from the appropriate ranges tf_bc = [] barcode_components = self . barcode_dict [ self . key_dict [ 'tf_map' ]] \\ [ self . key_dict [ 'tf_map_keys' ][ 'bc_components' ]] for component in barcode_components : comp_indicies = self . barcode_dict [ self . key_dict [ 'indicies' ]] \\ [ component ] tf_bc . append ( self . barcode [ comp_indicies [ 0 ]: comp_indicies [ 1 ]]) return \"\" . join ( tf_bc ) def get_tf ( self ): \"\"\"given a barcode string, return the tf if it exists in the tf map Args: barcode (Str): the barcode extracted from the read Returns: Str: If the barcode is found in the tf_dict, the tf name will be returned. else \"*\" \"\"\" if self . barcode == \"\" : raise AttributeError ( \"No barcode set\" ) # if the tf_map in the barcode_details DNE return \"*\" try : tf_barcode = self . get_tf_barcode () # if there is an exact match, return the TF try : tf = self . barcode_dict [ self . key_dict [ 'tf_dict' ]][ tf_barcode ] # but if there isn't, return the best matching tf and the edit # distance, eg MIG2_2 where the _2 is the edit distance and MIG2 # is the best match except KeyError : curr_min = 100 best_match = \"\" for bc in self . barcode_dict [ self . key_dict [ 'tf_dict' ]]: dist = self . edit_dist ( tf_barcode , bc ) if dist < curr_min : curr_min = dist best_match = self . barcode_dict [ self . key_dict [ 'tf_dict' ]][ bc ] tf = best_match + f \"_ { curr_min } \" except KeyError : tf = \"*\" return tf def tf_dict ( self , barcode_dict ): \"\"\"Set the tf_dict field in the barcode_dict attribute Raises: AttributeError: Raised if the number of items in the different TF barcode categories differ \"\"\" if self . key_dict [ 'tf_map' ] not in barcode_dict . keys (): raise KeyError ( f \" { self . key_dict [ 'tf_map' ] } not in barcode_dict\" ) # extract the following simply to make the dictionary comprehension # easier to read barcode_components = barcode_dict [ self . key_dict [ 'tf_map' ]] \\ [ self . key_dict [ 'tf_map_keys' ][ 'bc_components' ]] components_list = barcode_dict [ self . key_dict [ 'components' ]] # extract the lengths of each of the components of the barcode -- # if there are more than one, check to make sure that the lists are # of equal length component_lengths = { k : len ( components_list [ k ]) for k in barcode_components } expected_barcode_vector_length = component_lengths [ list ( component_lengths . keys ())[ 0 ]] # check that the number of elements in the given category matches # every other category for component , vector_length in component_lengths . items (): if vector_length != expected_barcode_vector_length : raise AttributeError ( f 'Number of items in barcode ' \\ f 'component { k } components lists do not match component \" \\ f\" { list ( component_lengths . keys ())[ 0 ] } ' ) # this will be constructed in the loop below. It will have the # structure {'sequence_barcode': TF_name , ... } tf_dict = {} for i in range ( expected_barcode_vector_length ): tf = barcode_dict [ self . key_dict [ 'tf_map' ]][ self . key_dict [ 'tf_map_keys' ][ 'tf' ]][ i ] tf_bc = [] for component in component_lengths : tf_bc . append ( barcode_dict [ self . key_dict [ 'components' ]][ component ][ i ]) if tf in tf_dict : raise KeyError ( f \"The same TF appears more than once in ]\" \\ f \" { self . key_dict [ 'tf_map' ] } \" ) # once the barcode is constructed, add it to the tf_dict tf_dict . update ({ \"\" . join ( tf_bc ): tf }) return tf_dict barcode_check () Determine if the barcode passes (True) or fails (False) given the edit distances between it and the expected components, and the allowable edit distance between a given component and the actual value. Parameters: Name Type Description Default component_edit_dist_dict Dict A dictionary where the keys are required Returns: Type Description Dict A dict of structure {\"pass\": Boolean, True if the barcode passes, \"tf\": Str, where the value is eithe \"*\" if unknown or a TF string from the barcode_details} Source code in callingcardstools/bam_parsers/BarcodeParser.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def barcode_check ( self ): \"\"\"Determine if the barcode passes (True) or fails (False) given the edit distances between it and the expected components, and the allowable edit distance between a given component and the actual value. Args: component_edit_dist_dict (Dict): A dictionary where the keys are barcode components and the values are the minimum edit distance of a given barcode against the corresponding allowable components Returns: (Dict): A dict of structure {\"pass\": Boolean, True if the barcode passes, \"tf\": Str, where the value is eithe \"*\" if unknown or a TF string from the barcode_details} \"\"\" if self . barcode == \"\" : raise AttributeError ( \"No barcode set\" ) tf = self . get_tf () component_edit_dist_dict = self . component_edit_distance () try : false_count = sum ([ 0 if v <= \\ self . barcode_dict [ self . key_dict [ 'match_allowance' ]][ k ] else 1 \\ for k , v in component_edit_dist_dict . items ()]) except KeyError : KeyError ( \"A given component was not present in the component match dict\" ) bc_pass = True if false_count == 0 else False return ({ \"pass\" : bc_pass , \"tf\" : tf }) component_edit_distance () Check the barcode against the expected values at each component substring location. Parameters: Name Type Description Default barcode Str A barcode string (the entire thing) required Raises: Type Description AttributeError Raised if self.barcode_dict is empty IndexError Raised if the indices of a given component are out Returns: Name Type Description Dict A dictionary where the component names are keys and the values are the minimum edit distance between the barcode component substring and the values listed in the barcode_details json Source code in callingcardstools/bam_parsers/BarcodeParser.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def component_edit_distance ( self ): \"\"\"Check the barcode against the expected values at each component substring location. Args: barcode (Str): A barcode string (the entire thing) Raises: AttributeError: Raised if self.barcode_dict is empty IndexError: Raised if the indices of a given component are out of bounds for the barcode input string Returns: Dict: A dictionary where the component names are keys and the values are the minimum edit distance between the barcode component substring and the values listed in the barcode_details json \"\"\" if self . barcode == \"\" : raise AttributeError ( \"No barcode set\" ) if not self . barcode_dict : raise AttributeError ( \"Barcode Dict is empty. Set a the barcode\" + \"dict by calling BarcodeChecker.set_barcode_details(json_path)\" ) # Using the keys of the barcode_components dict, make a dictionary # with structure {component1: \"TAG\", component2:\"TTAAGG\", ...} where the keys are # barcode components, and the values the substring of the barcode # which corresponds try : parsed_barcode_dict = \\ { k : self . barcode [ v [ 0 ]: v [ 1 ]] for k , v in self . barcode_dict [ 'indicies' ] . items ()} except IndexError as exc : raise f 'Barcode { self . barcode } does not have valid indicies for ' \\ f 'all expected barcode components. { exc } ' from exc # iterate over each part, return a dict in form {component: min_edit_dist} barcode_summary = { k : self . min_edit_dist ( k , v ) for k , v in parsed_barcode_dict . items ()} return barcode_summary edit_dist ( s1 , s2 ) Calculate the levenshtein distance between two strings Cite https://stackoverflow.com/a/32558749 Parameters: Name Type Description Default s1 Str One of two strings to match against the other required s2 Str One of two strings to match against the other required Returns: Name Type Description Int A number where 0 >= n <= longer of the two strings Source code in callingcardstools/bam_parsers/BarcodeParser.py 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 def edit_dist ( self , s1 , s2 ): \"\"\"Calculate the levenshtein distance between two strings Cite: https://stackoverflow.com/a/32558749 Args: s1 (Str): One of two strings to match against the other s2 (Str): One of two strings to match against the other Returns: Int: A number where 0 >= n <= longer of the two strings \"\"\" if len ( s1 ) > len ( s2 ): s1 , s2 = s2 , s1 distances = range ( len ( s1 ) + 1 ) for i2 , c2 in enumerate ( s2 ): distances_ = [ i2 + 1 ] for i1 , c1 in enumerate ( s1 ): if c1 == c2 : distances_ . append ( distances [ i1 ]) else : distances_ . append ( 1 + min (( distances [ i1 ], distances [ i1 + 1 ], distances_ [ - 1 ]))) distances = distances_ return distances [ - 1 ] get_insert_seqs () Getter for the insert seq sequence from the barcode details json Raises: Type Description AttributeError Raised if the current barcode details json does Returns: Name Type Description Str The insert seq string (upper case) from the barcode details Source code in callingcardstools/bam_parsers/BarcodeParser.py 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def get_insert_seqs ( self ): \"\"\"Getter for the insert seq sequence from the barcode details json Raises: AttributeError: Raised if the current barcode details json does not have an insert seq key Returns: Str: The insert seq string (upper case) from the barcode details \"\"\" if self . key_dict [ 'insert_seq' ] in self . barcode_dict : return self . barcode_dict [ self . key_dict [ 'insert_seq' ]] else : raise AttributeError ( f 'Current barcode details ' \\ f ' { self . barcode_details_json } does not have an ' \\ f 'insert seq component' ) get_tf () given a barcode string, return the tf if it exists in the tf map Parameters: Name Type Description Default barcode Str the barcode extracted from the read required Returns: Name Type Description Str If the barcode is found in the tf_dict, the tf name will be returned. else \"*\" Source code in callingcardstools/bam_parsers/BarcodeParser.py 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 def get_tf ( self ): \"\"\"given a barcode string, return the tf if it exists in the tf map Args: barcode (Str): the barcode extracted from the read Returns: Str: If the barcode is found in the tf_dict, the tf name will be returned. else \"*\" \"\"\" if self . barcode == \"\" : raise AttributeError ( \"No barcode set\" ) # if the tf_map in the barcode_details DNE return \"*\" try : tf_barcode = self . get_tf_barcode () # if there is an exact match, return the TF try : tf = self . barcode_dict [ self . key_dict [ 'tf_dict' ]][ tf_barcode ] # but if there isn't, return the best matching tf and the edit # distance, eg MIG2_2 where the _2 is the edit distance and MIG2 # is the best match except KeyError : curr_min = 100 best_match = \"\" for bc in self . barcode_dict [ self . key_dict [ 'tf_dict' ]]: dist = self . edit_dist ( tf_barcode , bc ) if dist < curr_min : curr_min = dist best_match = self . barcode_dict [ self . key_dict [ 'tf_dict' ]][ bc ] tf = best_match + f \"_ { curr_min } \" except KeyError : tf = \"*\" return tf get_tf_barcode () If the tf_map attribute is set, use the tf_bc_components to get the string at the correct indicies in the input barcode. Parameters: Name Type Description Default barcode Str the barcode extracted from a given read required Raises: Type Description KeyError Raised if tf_map does not exist in Returns: Name Type Description Str The substring of barcode at the indicies given in the tf_map.tf_bc_components Source code in callingcardstools/bam_parsers/BarcodeParser.py 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 def get_tf_barcode ( self ): \"\"\"If the tf_map attribute is set, use the tf_bc_components to get the string at the correct indicies in the input barcode. Args: barcode (Str): the barcode extracted from a given read Raises: KeyError: Raised if tf_map does not exist in self.barcode_dict Returns: Str: The substring of barcode at the indicies given in the tf_map.tf_bc_components \"\"\" if self . barcode == \"\" : raise AttributeError ( \"No barcode set\" ) if self . key_dict [ 'tf_map' ] not in self . barcode_dict . keys (): raise KeyError ( 'tf_map DNE' ) # extract the tf barcode from the appropriate ranges tf_bc = [] barcode_components = self . barcode_dict [ self . key_dict [ 'tf_map' ]] \\ [ self . key_dict [ 'tf_map_keys' ][ 'bc_components' ]] for component in barcode_components : comp_indicies = self . barcode_dict [ self . key_dict [ 'indicies' ]] \\ [ component ] tf_bc . append ( self . barcode [ comp_indicies [ 0 ]: comp_indicies [ 1 ]]) return \"\" . join ( tf_bc ) min_edit_dist ( barcode_component , barcode_substr ) get the minimum levenshtein edit distance between a given barcode component and the allowable strings for that component Parameters: Name Type Description Default barcode_component Str Name of a given barcode component required barcode_substr Str A substring of the read barcode to check required Raises: Type Description KeyError Raised if the barcode_component does not exist in Returns: Name Type Description Int The minimum distance between the barcode_substr and the values allowable for the barcode_component Source code in callingcardstools/bam_parsers/BarcodeParser.py 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 def min_edit_dist ( self , barcode_component , barcode_substr ): \"\"\"get the minimum levenshtein edit distance between a given barcode component and the allowable strings for that component Args: barcode_component (Str): Name of a given barcode component barcode_substr (Str): A substring of the read barcode to check against the the barcode_details['component'] list Raises: KeyError: Raised if the barcode_component does not exist in self.barcode_dict Returns: Int: The minimum distance between the barcode_substr and the values allowable for the barcode_component \"\"\" if barcode_component not in self . barcode_dict [ self . key_dict [ 'components' ]]: raise KeyError ( f \" { barcode_component } is not in \" \\ f \"the keys of the current barcode_details dict \" \\ f \" { self . barcode_details_json } \" ) min_dist = min ([ self . edit_dist ( barcode_substr , valid_component ) for \\ valid_component in self . barcode_dict [ self . key_dict [ 'components' ]][ barcode_component ]]) return min_dist set_barcode ( barcode ) setter for the barcode attribute. Note that the barcode is cast to upper Parameters: Name Type Description Default barcode str barcode to store in the barcode attribute required Source code in callingcardstools/bam_parsers/BarcodeParser.py 34 35 36 37 38 39 40 41 def set_barcode ( self , barcode ): \"\"\"setter for the barcode attribute. Note that the barcode is cast to upper Args: barcode (str): barcode to store in the barcode attribute \"\"\" self . barcode = barcode . upper () set_barcode_details ( barcode_details_json ) parse the calling cards bed file name column into components and perform This expects a dataframe with AT LEAST the columns (there may be more): ['chrom','chromStart','chromEnd','barcode', 'strand', 'insert_seq'] :param bed_df: :param barcode_details: :param fltr_bed_output_name: Source code in callingcardstools/bam_parsers/BarcodeParser.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def set_barcode_details ( self , barcode_details_json ): \"\"\"parse the calling cards bed file name column into components and perform This expects a dataframe with AT LEAST the columns (there may be more): ['chrom','chromStart','chromEnd','barcode', 'strand', 'insert_seq'] :param bed_df: :param barcode_details: :param fltr_bed_output_name: \"\"\" # check barcode_details path for input_path in [ barcode_details_json ]: if not os . path . exists ( input_path ): raise FileNotFoundError ( f \"Input file DNE: { input_path } \" ) # open json, read in as dict with open ( barcode_details_json ) as f1 : barcode_dict = json . load ( f1 ) # verify format barcode_dict = self . verify_barcode_details ( barcode_dict ) # update self self . barcode_dict = barcode_dict self . set_component_match_allowances () self . barcode_details_json = barcode_details_json set_component_match_allowances () update the barcode_dict attribute with match allowances for all components which are not already set in the barcode_details json Source code in callingcardstools/bam_parsers/BarcodeParser.py 144 145 146 147 148 149 150 151 152 153 def set_component_match_allowances ( self ): \"\"\"update the barcode_dict attribute with match allowances for all components which are not already set in the barcode_details json\"\"\" # if the match_allowance field DNE, create one with an empty dict x = self . barcode_dict . setdefault ( self . key_dict [ 'match_allowance' ], {}) # for each key in the barcode_dict[comp], set to 0 if it does not # already exist for comp in self . barcode_dict [ self . key_dict [ 'components' ]]: x = self . barcode_dict [ self . key_dict [ 'match_allowance' ]] \\ . setdefault ( comp , 0 ) tf_dict ( barcode_dict ) Set the tf_dict field in the barcode_dict attribute Raises: Type Description AttributeError Raised if the number of items in the different Source code in callingcardstools/bam_parsers/BarcodeParser.py 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 def tf_dict ( self , barcode_dict ): \"\"\"Set the tf_dict field in the barcode_dict attribute Raises: AttributeError: Raised if the number of items in the different TF barcode categories differ \"\"\" if self . key_dict [ 'tf_map' ] not in barcode_dict . keys (): raise KeyError ( f \" { self . key_dict [ 'tf_map' ] } not in barcode_dict\" ) # extract the following simply to make the dictionary comprehension # easier to read barcode_components = barcode_dict [ self . key_dict [ 'tf_map' ]] \\ [ self . key_dict [ 'tf_map_keys' ][ 'bc_components' ]] components_list = barcode_dict [ self . key_dict [ 'components' ]] # extract the lengths of each of the components of the barcode -- # if there are more than one, check to make sure that the lists are # of equal length component_lengths = { k : len ( components_list [ k ]) for k in barcode_components } expected_barcode_vector_length = component_lengths [ list ( component_lengths . keys ())[ 0 ]] # check that the number of elements in the given category matches # every other category for component , vector_length in component_lengths . items (): if vector_length != expected_barcode_vector_length : raise AttributeError ( f 'Number of items in barcode ' \\ f 'component { k } components lists do not match component \" \\ f\" { list ( component_lengths . keys ())[ 0 ] } ' ) # this will be constructed in the loop below. It will have the # structure {'sequence_barcode': TF_name , ... } tf_dict = {} for i in range ( expected_barcode_vector_length ): tf = barcode_dict [ self . key_dict [ 'tf_map' ]][ self . key_dict [ 'tf_map_keys' ][ 'tf' ]][ i ] tf_bc = [] for component in component_lengths : tf_bc . append ( barcode_dict [ self . key_dict [ 'components' ]][ component ][ i ]) if tf in tf_dict : raise KeyError ( f \"The same TF appears more than once in ]\" \\ f \" { self . key_dict [ 'tf_map' ] } \" ) # once the barcode is constructed, add it to the tf_dict tf_dict . update ({ \"\" . join ( tf_bc ): tf }) return tf_dict verify_barcode_details ( barcode_dict ) Verify expectations on the barcode details Parameters: Name Type Description Default barcode_dict dict A barcode_details dictionary parsed from the required Raises: Type Description KeyError Raised if an expected key in the barcode_details DNE ValueError Raised if a value in a given field in the barcode_details Returns: Type Description dict The verified barcode_details dictionary Source code in callingcardstools/bam_parsers/BarcodeParser.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def verify_barcode_details ( self , barcode_dict ): \"\"\"Verify expectations on the barcode details Args: barcode_dict (dict): A barcode_details dictionary parsed from the barcode_details json file Raises: KeyError: Raised if an expected key in the barcode_details DNE ValueError: Raised if a value in a given field in the barcode_details does not match expectations Returns: (dict): The verified barcode_details dictionary \"\"\" # check that the indicies and components match if not list ( barcode_dict [ self . key_dict [ 'components' ]] . keys ()) . sort () == \\ list ( barcode_dict [ self . key_dict [ 'indicies' ]] . keys ()) . sort (): raise KeyError ( 'The keys in the barcode_component json and the ' + 'barcode_component_indicies json are not the same' ) # check that the components are the correct length according to the # indicies barcode_components_length_check_dict = { k : v [ 1 ] - v [ 0 ] for k , v in \\ barcode_dict [ 'indicies' ] . items ()} for k , v in barcode_dict [ 'components' ] . items (): for comp in v : if not len ( comp ) == barcode_components_length_check_dict [ k ]: raise ValueError ( f \"There exists a component in \" \\ f \"barcode_components which is not the length \" \\ f \"described by the barcode_details['indicies']: \" \\ f \" { comp } , { barcode_components_length_check_dict [ k ] } \" ) # if a tf_map dict exists, check that the bc_components and tf list # exist if self . key_dict [ 'tf_map' ] in barcode_dict : for bc_comp in barcode_dict [ self . key_dict [ 'tf_map' ]] \\ [ self . key_dict [ 'tf_map_keys' ][ 'bc_components' ]]: if bc_comp not in barcode_dict [ self . key_dict [ 'components' ]]: raise KeyError ( f \"tf barcode component { bc_comp } is not \" \\ f \"in barcode details { self . key_dict [ 'components' ] } \" ) # if the match_allowance field exists, check that the components match # those in the components field, and that the distance is an integer if self . key_dict [ 'match_allowance' ] in barcode_dict : for comp , dist in barcode_dict [ self . key_dict [ 'match_allowance' ]] . items (): if comp not in barcode_dict [ self . key_dict [ 'components' ]]: raise KeyError ( f \"The keys in \" \\ f \" { self . barcode_dict [ self . key_dict [ 'match_allowance' ]] } \" \\ f \"must be in { self . barcode_dict [ self . key_dict [ 'components' ]] } \" ) if not isinstance ( dist , int ) or dist < 0 : raise ValueError ( \"Match allowance must be a positive integer which \\ represents the maximum edit distance from the expected \\ barcode\" ) # cast all values in self.key_dict['components'] to upper # note that the barcode is also always cast to upper upper_components_dict = {} for k , seq_list in barcode_dict [ self . key_dict [ 'components' ]] . items (): upper_seq_list = [] for sequence in seq_list : upper_seq_list . append ( sequence . upper ()) upper_components_dict . setdefault ( k , upper_seq_list ) barcode_dict [ self . key_dict [ 'components' ]] = upper_components_dict # cast insert seq to upper if it exists if self . key_dict [ 'insert_seq' ] in barcode_dict : upper_insert_seq = [] for sequence in barcode_dict [ self . key_dict [ 'insert_seq' ]]: upper_insert_seq . append ( sequence . upper ()) barcode_dict [ self . key_dict [ 'insert_seq' ]] = upper_insert_seq # if tf_map exists, then set the tf_dict if self . key_dict [ 'tf_map' ] in barcode_dict : barcode_dict [ self . key_dict [ 'tf_dict' ]] = self . tf_dict ( barcode_dict ) return barcode_dict","title":"BarcodeParser"},{"location":"bam_parser/BarcodeParser/#callingcardstools.bam_parsers.BarcodeParser.BarcodeParser.barcode_check","text":"Determine if the barcode passes (True) or fails (False) given the edit distances between it and the expected components, and the allowable edit distance between a given component and the actual value. Parameters: Name Type Description Default component_edit_dist_dict Dict A dictionary where the keys are required Returns: Type Description Dict A dict of structure {\"pass\": Boolean, True if the barcode passes, \"tf\": Str, where the value is eithe \"*\" if unknown or a TF string from the barcode_details} Source code in callingcardstools/bam_parsers/BarcodeParser.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def barcode_check ( self ): \"\"\"Determine if the barcode passes (True) or fails (False) given the edit distances between it and the expected components, and the allowable edit distance between a given component and the actual value. Args: component_edit_dist_dict (Dict): A dictionary where the keys are barcode components and the values are the minimum edit distance of a given barcode against the corresponding allowable components Returns: (Dict): A dict of structure {\"pass\": Boolean, True if the barcode passes, \"tf\": Str, where the value is eithe \"*\" if unknown or a TF string from the barcode_details} \"\"\" if self . barcode == \"\" : raise AttributeError ( \"No barcode set\" ) tf = self . get_tf () component_edit_dist_dict = self . component_edit_distance () try : false_count = sum ([ 0 if v <= \\ self . barcode_dict [ self . key_dict [ 'match_allowance' ]][ k ] else 1 \\ for k , v in component_edit_dist_dict . items ()]) except KeyError : KeyError ( \"A given component was not present in the component match dict\" ) bc_pass = True if false_count == 0 else False return ({ \"pass\" : bc_pass , \"tf\" : tf })","title":"barcode_check()"},{"location":"bam_parser/BarcodeParser/#callingcardstools.bam_parsers.BarcodeParser.BarcodeParser.component_edit_distance","text":"Check the barcode against the expected values at each component substring location. Parameters: Name Type Description Default barcode Str A barcode string (the entire thing) required Raises: Type Description AttributeError Raised if self.barcode_dict is empty IndexError Raised if the indices of a given component are out Returns: Name Type Description Dict A dictionary where the component names are keys and the values are the minimum edit distance between the barcode component substring and the values listed in the barcode_details json Source code in callingcardstools/bam_parsers/BarcodeParser.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def component_edit_distance ( self ): \"\"\"Check the barcode against the expected values at each component substring location. Args: barcode (Str): A barcode string (the entire thing) Raises: AttributeError: Raised if self.barcode_dict is empty IndexError: Raised if the indices of a given component are out of bounds for the barcode input string Returns: Dict: A dictionary where the component names are keys and the values are the minimum edit distance between the barcode component substring and the values listed in the barcode_details json \"\"\" if self . barcode == \"\" : raise AttributeError ( \"No barcode set\" ) if not self . barcode_dict : raise AttributeError ( \"Barcode Dict is empty. Set a the barcode\" + \"dict by calling BarcodeChecker.set_barcode_details(json_path)\" ) # Using the keys of the barcode_components dict, make a dictionary # with structure {component1: \"TAG\", component2:\"TTAAGG\", ...} where the keys are # barcode components, and the values the substring of the barcode # which corresponds try : parsed_barcode_dict = \\ { k : self . barcode [ v [ 0 ]: v [ 1 ]] for k , v in self . barcode_dict [ 'indicies' ] . items ()} except IndexError as exc : raise f 'Barcode { self . barcode } does not have valid indicies for ' \\ f 'all expected barcode components. { exc } ' from exc # iterate over each part, return a dict in form {component: min_edit_dist} barcode_summary = { k : self . min_edit_dist ( k , v ) for k , v in parsed_barcode_dict . items ()} return barcode_summary","title":"component_edit_distance()"},{"location":"bam_parser/BarcodeParser/#callingcardstools.bam_parsers.BarcodeParser.BarcodeParser.edit_dist","text":"Calculate the levenshtein distance between two strings Cite https://stackoverflow.com/a/32558749 Parameters: Name Type Description Default s1 Str One of two strings to match against the other required s2 Str One of two strings to match against the other required Returns: Name Type Description Int A number where 0 >= n <= longer of the two strings Source code in callingcardstools/bam_parsers/BarcodeParser.py 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 def edit_dist ( self , s1 , s2 ): \"\"\"Calculate the levenshtein distance between two strings Cite: https://stackoverflow.com/a/32558749 Args: s1 (Str): One of two strings to match against the other s2 (Str): One of two strings to match against the other Returns: Int: A number where 0 >= n <= longer of the two strings \"\"\" if len ( s1 ) > len ( s2 ): s1 , s2 = s2 , s1 distances = range ( len ( s1 ) + 1 ) for i2 , c2 in enumerate ( s2 ): distances_ = [ i2 + 1 ] for i1 , c1 in enumerate ( s1 ): if c1 == c2 : distances_ . append ( distances [ i1 ]) else : distances_ . append ( 1 + min (( distances [ i1 ], distances [ i1 + 1 ], distances_ [ - 1 ]))) distances = distances_ return distances [ - 1 ]","title":"edit_dist()"},{"location":"bam_parser/BarcodeParser/#callingcardstools.bam_parsers.BarcodeParser.BarcodeParser.get_insert_seqs","text":"Getter for the insert seq sequence from the barcode details json Raises: Type Description AttributeError Raised if the current barcode details json does Returns: Name Type Description Str The insert seq string (upper case) from the barcode details Source code in callingcardstools/bam_parsers/BarcodeParser.py 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def get_insert_seqs ( self ): \"\"\"Getter for the insert seq sequence from the barcode details json Raises: AttributeError: Raised if the current barcode details json does not have an insert seq key Returns: Str: The insert seq string (upper case) from the barcode details \"\"\" if self . key_dict [ 'insert_seq' ] in self . barcode_dict : return self . barcode_dict [ self . key_dict [ 'insert_seq' ]] else : raise AttributeError ( f 'Current barcode details ' \\ f ' { self . barcode_details_json } does not have an ' \\ f 'insert seq component' )","title":"get_insert_seqs()"},{"location":"bam_parser/BarcodeParser/#callingcardstools.bam_parsers.BarcodeParser.BarcodeParser.get_tf","text":"given a barcode string, return the tf if it exists in the tf map Parameters: Name Type Description Default barcode Str the barcode extracted from the read required Returns: Name Type Description Str If the barcode is found in the tf_dict, the tf name will be returned. else \"*\" Source code in callingcardstools/bam_parsers/BarcodeParser.py 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 def get_tf ( self ): \"\"\"given a barcode string, return the tf if it exists in the tf map Args: barcode (Str): the barcode extracted from the read Returns: Str: If the barcode is found in the tf_dict, the tf name will be returned. else \"*\" \"\"\" if self . barcode == \"\" : raise AttributeError ( \"No barcode set\" ) # if the tf_map in the barcode_details DNE return \"*\" try : tf_barcode = self . get_tf_barcode () # if there is an exact match, return the TF try : tf = self . barcode_dict [ self . key_dict [ 'tf_dict' ]][ tf_barcode ] # but if there isn't, return the best matching tf and the edit # distance, eg MIG2_2 where the _2 is the edit distance and MIG2 # is the best match except KeyError : curr_min = 100 best_match = \"\" for bc in self . barcode_dict [ self . key_dict [ 'tf_dict' ]]: dist = self . edit_dist ( tf_barcode , bc ) if dist < curr_min : curr_min = dist best_match = self . barcode_dict [ self . key_dict [ 'tf_dict' ]][ bc ] tf = best_match + f \"_ { curr_min } \" except KeyError : tf = \"*\" return tf","title":"get_tf()"},{"location":"bam_parser/BarcodeParser/#callingcardstools.bam_parsers.BarcodeParser.BarcodeParser.get_tf_barcode","text":"If the tf_map attribute is set, use the tf_bc_components to get the string at the correct indicies in the input barcode. Parameters: Name Type Description Default barcode Str the barcode extracted from a given read required Raises: Type Description KeyError Raised if tf_map does not exist in Returns: Name Type Description Str The substring of barcode at the indicies given in the tf_map.tf_bc_components Source code in callingcardstools/bam_parsers/BarcodeParser.py 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 def get_tf_barcode ( self ): \"\"\"If the tf_map attribute is set, use the tf_bc_components to get the string at the correct indicies in the input barcode. Args: barcode (Str): the barcode extracted from a given read Raises: KeyError: Raised if tf_map does not exist in self.barcode_dict Returns: Str: The substring of barcode at the indicies given in the tf_map.tf_bc_components \"\"\" if self . barcode == \"\" : raise AttributeError ( \"No barcode set\" ) if self . key_dict [ 'tf_map' ] not in self . barcode_dict . keys (): raise KeyError ( 'tf_map DNE' ) # extract the tf barcode from the appropriate ranges tf_bc = [] barcode_components = self . barcode_dict [ self . key_dict [ 'tf_map' ]] \\ [ self . key_dict [ 'tf_map_keys' ][ 'bc_components' ]] for component in barcode_components : comp_indicies = self . barcode_dict [ self . key_dict [ 'indicies' ]] \\ [ component ] tf_bc . append ( self . barcode [ comp_indicies [ 0 ]: comp_indicies [ 1 ]]) return \"\" . join ( tf_bc )","title":"get_tf_barcode()"},{"location":"bam_parser/BarcodeParser/#callingcardstools.bam_parsers.BarcodeParser.BarcodeParser.min_edit_dist","text":"get the minimum levenshtein edit distance between a given barcode component and the allowable strings for that component Parameters: Name Type Description Default barcode_component Str Name of a given barcode component required barcode_substr Str A substring of the read barcode to check required Raises: Type Description KeyError Raised if the barcode_component does not exist in Returns: Name Type Description Int The minimum distance between the barcode_substr and the values allowable for the barcode_component Source code in callingcardstools/bam_parsers/BarcodeParser.py 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 def min_edit_dist ( self , barcode_component , barcode_substr ): \"\"\"get the minimum levenshtein edit distance between a given barcode component and the allowable strings for that component Args: barcode_component (Str): Name of a given barcode component barcode_substr (Str): A substring of the read barcode to check against the the barcode_details['component'] list Raises: KeyError: Raised if the barcode_component does not exist in self.barcode_dict Returns: Int: The minimum distance between the barcode_substr and the values allowable for the barcode_component \"\"\" if barcode_component not in self . barcode_dict [ self . key_dict [ 'components' ]]: raise KeyError ( f \" { barcode_component } is not in \" \\ f \"the keys of the current barcode_details dict \" \\ f \" { self . barcode_details_json } \" ) min_dist = min ([ self . edit_dist ( barcode_substr , valid_component ) for \\ valid_component in self . barcode_dict [ self . key_dict [ 'components' ]][ barcode_component ]]) return min_dist","title":"min_edit_dist()"},{"location":"bam_parser/BarcodeParser/#callingcardstools.bam_parsers.BarcodeParser.BarcodeParser.set_barcode","text":"setter for the barcode attribute. Note that the barcode is cast to upper Parameters: Name Type Description Default barcode str barcode to store in the barcode attribute required Source code in callingcardstools/bam_parsers/BarcodeParser.py 34 35 36 37 38 39 40 41 def set_barcode ( self , barcode ): \"\"\"setter for the barcode attribute. Note that the barcode is cast to upper Args: barcode (str): barcode to store in the barcode attribute \"\"\" self . barcode = barcode . upper ()","title":"set_barcode()"},{"location":"bam_parser/BarcodeParser/#callingcardstools.bam_parsers.BarcodeParser.BarcodeParser.set_barcode_details","text":"parse the calling cards bed file name column into components and perform This expects a dataframe with AT LEAST the columns (there may be more): ['chrom','chromStart','chromEnd','barcode', 'strand', 'insert_seq'] :param bed_df: :param barcode_details: :param fltr_bed_output_name: Source code in callingcardstools/bam_parsers/BarcodeParser.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def set_barcode_details ( self , barcode_details_json ): \"\"\"parse the calling cards bed file name column into components and perform This expects a dataframe with AT LEAST the columns (there may be more): ['chrom','chromStart','chromEnd','barcode', 'strand', 'insert_seq'] :param bed_df: :param barcode_details: :param fltr_bed_output_name: \"\"\" # check barcode_details path for input_path in [ barcode_details_json ]: if not os . path . exists ( input_path ): raise FileNotFoundError ( f \"Input file DNE: { input_path } \" ) # open json, read in as dict with open ( barcode_details_json ) as f1 : barcode_dict = json . load ( f1 ) # verify format barcode_dict = self . verify_barcode_details ( barcode_dict ) # update self self . barcode_dict = barcode_dict self . set_component_match_allowances () self . barcode_details_json = barcode_details_json","title":"set_barcode_details()"},{"location":"bam_parser/BarcodeParser/#callingcardstools.bam_parsers.BarcodeParser.BarcodeParser.set_component_match_allowances","text":"update the barcode_dict attribute with match allowances for all components which are not already set in the barcode_details json Source code in callingcardstools/bam_parsers/BarcodeParser.py 144 145 146 147 148 149 150 151 152 153 def set_component_match_allowances ( self ): \"\"\"update the barcode_dict attribute with match allowances for all components which are not already set in the barcode_details json\"\"\" # if the match_allowance field DNE, create one with an empty dict x = self . barcode_dict . setdefault ( self . key_dict [ 'match_allowance' ], {}) # for each key in the barcode_dict[comp], set to 0 if it does not # already exist for comp in self . barcode_dict [ self . key_dict [ 'components' ]]: x = self . barcode_dict [ self . key_dict [ 'match_allowance' ]] \\ . setdefault ( comp , 0 )","title":"set_component_match_allowances()"},{"location":"bam_parser/BarcodeParser/#callingcardstools.bam_parsers.BarcodeParser.BarcodeParser.tf_dict","text":"Set the tf_dict field in the barcode_dict attribute Raises: Type Description AttributeError Raised if the number of items in the different Source code in callingcardstools/bam_parsers/BarcodeParser.py 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 def tf_dict ( self , barcode_dict ): \"\"\"Set the tf_dict field in the barcode_dict attribute Raises: AttributeError: Raised if the number of items in the different TF barcode categories differ \"\"\" if self . key_dict [ 'tf_map' ] not in barcode_dict . keys (): raise KeyError ( f \" { self . key_dict [ 'tf_map' ] } not in barcode_dict\" ) # extract the following simply to make the dictionary comprehension # easier to read barcode_components = barcode_dict [ self . key_dict [ 'tf_map' ]] \\ [ self . key_dict [ 'tf_map_keys' ][ 'bc_components' ]] components_list = barcode_dict [ self . key_dict [ 'components' ]] # extract the lengths of each of the components of the barcode -- # if there are more than one, check to make sure that the lists are # of equal length component_lengths = { k : len ( components_list [ k ]) for k in barcode_components } expected_barcode_vector_length = component_lengths [ list ( component_lengths . keys ())[ 0 ]] # check that the number of elements in the given category matches # every other category for component , vector_length in component_lengths . items (): if vector_length != expected_barcode_vector_length : raise AttributeError ( f 'Number of items in barcode ' \\ f 'component { k } components lists do not match component \" \\ f\" { list ( component_lengths . keys ())[ 0 ] } ' ) # this will be constructed in the loop below. It will have the # structure {'sequence_barcode': TF_name , ... } tf_dict = {} for i in range ( expected_barcode_vector_length ): tf = barcode_dict [ self . key_dict [ 'tf_map' ]][ self . key_dict [ 'tf_map_keys' ][ 'tf' ]][ i ] tf_bc = [] for component in component_lengths : tf_bc . append ( barcode_dict [ self . key_dict [ 'components' ]][ component ][ i ]) if tf in tf_dict : raise KeyError ( f \"The same TF appears more than once in ]\" \\ f \" { self . key_dict [ 'tf_map' ] } \" ) # once the barcode is constructed, add it to the tf_dict tf_dict . update ({ \"\" . join ( tf_bc ): tf }) return tf_dict","title":"tf_dict()"},{"location":"bam_parser/BarcodeParser/#callingcardstools.bam_parsers.BarcodeParser.BarcodeParser.verify_barcode_details","text":"Verify expectations on the barcode details Parameters: Name Type Description Default barcode_dict dict A barcode_details dictionary parsed from the required Raises: Type Description KeyError Raised if an expected key in the barcode_details DNE ValueError Raised if a value in a given field in the barcode_details Returns: Type Description dict The verified barcode_details dictionary Source code in callingcardstools/bam_parsers/BarcodeParser.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def verify_barcode_details ( self , barcode_dict ): \"\"\"Verify expectations on the barcode details Args: barcode_dict (dict): A barcode_details dictionary parsed from the barcode_details json file Raises: KeyError: Raised if an expected key in the barcode_details DNE ValueError: Raised if a value in a given field in the barcode_details does not match expectations Returns: (dict): The verified barcode_details dictionary \"\"\" # check that the indicies and components match if not list ( barcode_dict [ self . key_dict [ 'components' ]] . keys ()) . sort () == \\ list ( barcode_dict [ self . key_dict [ 'indicies' ]] . keys ()) . sort (): raise KeyError ( 'The keys in the barcode_component json and the ' + 'barcode_component_indicies json are not the same' ) # check that the components are the correct length according to the # indicies barcode_components_length_check_dict = { k : v [ 1 ] - v [ 0 ] for k , v in \\ barcode_dict [ 'indicies' ] . items ()} for k , v in barcode_dict [ 'components' ] . items (): for comp in v : if not len ( comp ) == barcode_components_length_check_dict [ k ]: raise ValueError ( f \"There exists a component in \" \\ f \"barcode_components which is not the length \" \\ f \"described by the barcode_details['indicies']: \" \\ f \" { comp } , { barcode_components_length_check_dict [ k ] } \" ) # if a tf_map dict exists, check that the bc_components and tf list # exist if self . key_dict [ 'tf_map' ] in barcode_dict : for bc_comp in barcode_dict [ self . key_dict [ 'tf_map' ]] \\ [ self . key_dict [ 'tf_map_keys' ][ 'bc_components' ]]: if bc_comp not in barcode_dict [ self . key_dict [ 'components' ]]: raise KeyError ( f \"tf barcode component { bc_comp } is not \" \\ f \"in barcode details { self . key_dict [ 'components' ] } \" ) # if the match_allowance field exists, check that the components match # those in the components field, and that the distance is an integer if self . key_dict [ 'match_allowance' ] in barcode_dict : for comp , dist in barcode_dict [ self . key_dict [ 'match_allowance' ]] . items (): if comp not in barcode_dict [ self . key_dict [ 'components' ]]: raise KeyError ( f \"The keys in \" \\ f \" { self . barcode_dict [ self . key_dict [ 'match_allowance' ]] } \" \\ f \"must be in { self . barcode_dict [ self . key_dict [ 'components' ]] } \" ) if not isinstance ( dist , int ) or dist < 0 : raise ValueError ( \"Match allowance must be a positive integer which \\ represents the maximum edit distance from the expected \\ barcode\" ) # cast all values in self.key_dict['components'] to upper # note that the barcode is also always cast to upper upper_components_dict = {} for k , seq_list in barcode_dict [ self . key_dict [ 'components' ]] . items (): upper_seq_list = [] for sequence in seq_list : upper_seq_list . append ( sequence . upper ()) upper_components_dict . setdefault ( k , upper_seq_list ) barcode_dict [ self . key_dict [ 'components' ]] = upper_components_dict # cast insert seq to upper if it exists if self . key_dict [ 'insert_seq' ] in barcode_dict : upper_insert_seq = [] for sequence in barcode_dict [ self . key_dict [ 'insert_seq' ]]: upper_insert_seq . append ( sequence . upper ()) barcode_dict [ self . key_dict [ 'insert_seq' ]] = upper_insert_seq # if tf_map exists, then set the tf_dict if self . key_dict [ 'tf_map' ] in barcode_dict : barcode_dict [ self . key_dict [ 'tf_dict' ]] = self . tf_dict ( barcode_dict ) return barcode_dict","title":"verify_barcode_details()"},{"location":"create_assets/create_chr_map/","text":"Create chromosome name mappings The goal is to create a frame which maps the various genome assembly chromosome names to one another, for instance, from UCSC to ensembl. I prefer to do this in R. load dependencies library(rtracklayer) library(tidyverse) save paths and the regex used to clean the seqnames from the fasta These were downloaded from their respective sites on 20220812 genome_paths = list( ensembl = \"~/Downloads/homo_sapien/ensembl_genome.fa\", ucsc = \"~/Downloads/homo_sapien/ucsc_genome.fa\", refseq = \"~/Downloads/homo_sapien/refseq_genome.fa\", genbank = \"~/Downloads/homo_sapien/genbank_genome.fa\" ) These regex patterns were determined by looking at the names in the fasta file extract_seqnames_regex = list( refseq = \"GRCh38.p14 Primary Assembly$|mitochondrion, complete genome$\", genbank = \"[\\\\d,X,Y], GRCh38 reference primary assembly$|mitochondrion, complete genome$\" ) create a list of the primary 22 autosomes, XY and mitochondria for each source genomes = list( ensembl = unlist(map(str_split( names(rtracklayer::import(genome_paths$ensembl, format = \"fasta\"))[1:25], \" \"), ~.[[1]][[1]])), ucsc = names(rtracklayer::import(genome_paths$ucsc, format = \"fasta\"))[1:25], refseq = names(rtracklayer::import(genome_paths$refseq, format = \"fasta\")) %>% .[str_detect(., extract_seqnames_regex$refseq)], genbank = names(rtracklayer::import(genome_paths$genbank, format = \"fasta\")) %>% .[str_detect(., extract_seqnames_regex$genbank)] ) Create a frame which allows mapping between sources Note that gencode is the same as UCSC clean_seqnames_regex = list( refseq = \"NC_\\\\d+.\\\\d+ Homo sapiens chromosome |NC_\\\\d+.\\\\d+ Homo sapiens|, GRCh38.p14 Primary Assembly|, complete genome\", genbank = \"CM\\\\d+.\\\\d+ Homo sapiens chromosome |J\\\\d+.\\\\d+ Homo sapiens|, GRCh38 reference primary assembly|, complete genome\" ) genomes_df_list = list( ensembl = tibble( ensembl = genomes$ensembl, seq = genomes$ensembl), ucsc = tibble( ucsc = genomes$ucsc, seq = str_remove(genomes$ucsc, \"chr\")), # gencode is the same as ucsc gencode = tibble( gencode = genomes$ucsc, seq = str_remove(genomes$ucsc, \"chr\")), refseq = tibble( refseq = unlist(map(str_split(genomes$refseq, \" \"), ~.[[1]][[1]])), seq = str_remove_all(genomes$refseq, clean_seqnames_regex$refseq)), genbank = tibble( genbank = unlist(map(str_split(genomes$genbank, \" \"), ~.[[1]][[1]])), seq = str_remove_all(genomes$genbank, clean_seqnames_regex$genbank)) ) cleanup_genomes_df = function(df){ df %>% mutate(seq = ifelse(str_detect(seq, \"mitochondrion|MT\"), \"M\", seq)) } genomes_df_list = map(genomes_df_list, cleanup_genomes_df) chr_map = genomes_df_list %>% reduce(left_join) %>% select(-seq) write_csv(chr_map, \"~/code/nf-core-callingcards/assets/human/chr_map.csv\")","title":"Chromosome Name Map"},{"location":"create_assets/create_chr_map/#create-chromosome-name-mappings","text":"The goal is to create a frame which maps the various genome assembly chromosome names to one another, for instance, from UCSC to ensembl. I prefer to do this in R.","title":"Create chromosome name mappings"},{"location":"create_assets/create_chr_map/#load-dependencies","text":"library(rtracklayer) library(tidyverse)","title":"load dependencies"},{"location":"create_assets/create_chr_map/#save-paths-and-the-regex-used-to-clean-the-seqnames-from-the-fasta","text":"These were downloaded from their respective sites on 20220812 genome_paths = list( ensembl = \"~/Downloads/homo_sapien/ensembl_genome.fa\", ucsc = \"~/Downloads/homo_sapien/ucsc_genome.fa\", refseq = \"~/Downloads/homo_sapien/refseq_genome.fa\", genbank = \"~/Downloads/homo_sapien/genbank_genome.fa\" ) These regex patterns were determined by looking at the names in the fasta file extract_seqnames_regex = list( refseq = \"GRCh38.p14 Primary Assembly$|mitochondrion, complete genome$\", genbank = \"[\\\\d,X,Y], GRCh38 reference primary assembly$|mitochondrion, complete genome$\" )","title":"save paths and the regex used to clean the seqnames from the fasta"},{"location":"create_assets/create_chr_map/#create-a-list-of-the-primary-22-autosomes-xy-and-mitochondria-for-each-source","text":"genomes = list( ensembl = unlist(map(str_split( names(rtracklayer::import(genome_paths$ensembl, format = \"fasta\"))[1:25], \" \"), ~.[[1]][[1]])), ucsc = names(rtracklayer::import(genome_paths$ucsc, format = \"fasta\"))[1:25], refseq = names(rtracklayer::import(genome_paths$refseq, format = \"fasta\")) %>% .[str_detect(., extract_seqnames_regex$refseq)], genbank = names(rtracklayer::import(genome_paths$genbank, format = \"fasta\")) %>% .[str_detect(., extract_seqnames_regex$genbank)] )","title":"create a list of the primary 22 autosomes, XY and mitochondria for each source"},{"location":"create_assets/create_chr_map/#create-a-frame-which-allows-mapping-between-sources","text":"Note that gencode is the same as UCSC clean_seqnames_regex = list( refseq = \"NC_\\\\d+.\\\\d+ Homo sapiens chromosome |NC_\\\\d+.\\\\d+ Homo sapiens|, GRCh38.p14 Primary Assembly|, complete genome\", genbank = \"CM\\\\d+.\\\\d+ Homo sapiens chromosome |J\\\\d+.\\\\d+ Homo sapiens|, GRCh38 reference primary assembly|, complete genome\" ) genomes_df_list = list( ensembl = tibble( ensembl = genomes$ensembl, seq = genomes$ensembl), ucsc = tibble( ucsc = genomes$ucsc, seq = str_remove(genomes$ucsc, \"chr\")), # gencode is the same as ucsc gencode = tibble( gencode = genomes$ucsc, seq = str_remove(genomes$ucsc, \"chr\")), refseq = tibble( refseq = unlist(map(str_split(genomes$refseq, \" \"), ~.[[1]][[1]])), seq = str_remove_all(genomes$refseq, clean_seqnames_regex$refseq)), genbank = tibble( genbank = unlist(map(str_split(genomes$genbank, \" \"), ~.[[1]][[1]])), seq = str_remove_all(genomes$genbank, clean_seqnames_regex$genbank)) ) cleanup_genomes_df = function(df){ df %>% mutate(seq = ifelse(str_detect(seq, \"mitochondrion|MT\"), \"M\", seq)) } genomes_df_list = map(genomes_df_list, cleanup_genomes_df) chr_map = genomes_df_list %>% reduce(left_join) %>% select(-seq) write_csv(chr_map, \"~/code/nf-core-callingcards/assets/human/chr_map.csv\")","title":"Create a frame which allows mapping between sources"},{"location":"user-guide/getting-started/","text":"","title":"Getting started"}]}