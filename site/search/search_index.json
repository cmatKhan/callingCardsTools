{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Reference Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#reference","text":"","title":"Reference"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"about/license/","text":"The MIT License (MIT) Copyright \u00a9 2022 Chase Mateusiak Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"about/license/#the-mit-license-mit","text":"Copyright \u00a9 2022 Chase Mateusiak Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"The MIT License (MIT)"},{"location":"create_assets/create_chr_map/","text":"Create chromosome name mappings The goal is to create a frame which maps the various genome assembly chromosome names to one another, for instance, from UCSC to ensembl. I prefer to do this in R. library(rtracklayer) library(tidyverse) genomes = list( ensembl = unlist(map(str_split( names(rtracklayer::import( \"~/Downloads/homo_sapien/ensembl_genome.fa\", format = \"fasta\"))[1:25], \" \"), ~.[[1]][[1]])), ucsc = names(rtracklayer::import( \"~/Downloads/homo_sapien/ucsc_genome.fa\", format = \"fasta\") )[1:25], refseq = names(rtracklayer::import( \"~/Downloads/homo_sapien/refseq_genome.fa\", format = \"fasta\")) %>% .[ str_detect(., \"GRCh38.p14 Primary Assembly$|mitochondrion, complete genome$\") ], genbank = names(rtracklayer::import( \"~/Downloads/homo_sapien/genbank_genome.fa\", format = \"fasta\")) %>% .[ str_detect(., \"[\\\\d,X,Y], GRCh38 reference primary assembly$|mitochondrion, complete genome$\") ] ) genomes_df_list = list( ensembl = tibble(ensembl = genomes$ensembl, seq = genomes$ensembl), ucsc = tibble(ucsc = genomes$ucsc, seq = str_remove(genomes$ucsc, \"chr\")), gencode = tibble(gencode = genomes$ucsc, seq = str_remove(genomes$ucsc, \"chr\")), gencode = tibble(ucsc = genomes$ucsc, seq = str_remove(genomes$ucsc, \"chr\")), refseq = tibble(refseq = unlist(map(str_split(genomes$refseq, \" \"), ~.[[1]][[1]])), seq = str_remove_all(genomes$refseq, \"NC_\\\\d+.\\\\d+ Homo sapiens chromosome |NC_\\\\d+.\\\\d+ Homo sapiens|, GRCh38.p14 Primary Assembly|, complete genome\")), genbank = tibble(genbank = unlist(map(str_split(genomes$genbank, \" \"), ~.[[1]][[1]])), seq = str_remove_all(genomes$genbank, \"CM\\\\d+.\\\\d+ Homo sapiens chromosome |J\\\\d+.\\\\d+ Homo sapiens|, GRCh38 reference primary assembly|, complete genome\")) ) cleanup_genomes_df = function(df){ df %>% mutate(seq = ifelse(str_detect(seq, \"mitochondrion|MT\"), \"M\", seq)) } genomes_df_list = map(genomes_df_list, cleanup_genomes_df) chr_map = genomes_df_list %>% reduce(left_join) %>% select(-seq)","title":"Chromosome Name Map"},{"location":"create_assets/create_chr_map/#create-chromosome-name-mappings","text":"The goal is to create a frame which maps the various genome assembly chromosome names to one another, for instance, from UCSC to ensembl. I prefer to do this in R. library(rtracklayer) library(tidyverse) genomes = list( ensembl = unlist(map(str_split( names(rtracklayer::import( \"~/Downloads/homo_sapien/ensembl_genome.fa\", format = \"fasta\"))[1:25], \" \"), ~.[[1]][[1]])), ucsc = names(rtracklayer::import( \"~/Downloads/homo_sapien/ucsc_genome.fa\", format = \"fasta\") )[1:25], refseq = names(rtracklayer::import( \"~/Downloads/homo_sapien/refseq_genome.fa\", format = \"fasta\")) %>% .[ str_detect(., \"GRCh38.p14 Primary Assembly$|mitochondrion, complete genome$\") ], genbank = names(rtracklayer::import( \"~/Downloads/homo_sapien/genbank_genome.fa\", format = \"fasta\")) %>% .[ str_detect(., \"[\\\\d,X,Y], GRCh38 reference primary assembly$|mitochondrion, complete genome$\") ] ) genomes_df_list = list( ensembl = tibble(ensembl = genomes$ensembl, seq = genomes$ensembl), ucsc = tibble(ucsc = genomes$ucsc, seq = str_remove(genomes$ucsc, \"chr\")), gencode = tibble(gencode = genomes$ucsc, seq = str_remove(genomes$ucsc, \"chr\")), gencode = tibble(ucsc = genomes$ucsc, seq = str_remove(genomes$ucsc, \"chr\")), refseq = tibble(refseq = unlist(map(str_split(genomes$refseq, \" \"), ~.[[1]][[1]])), seq = str_remove_all(genomes$refseq, \"NC_\\\\d+.\\\\d+ Homo sapiens chromosome |NC_\\\\d+.\\\\d+ Homo sapiens|, GRCh38.p14 Primary Assembly|, complete genome\")), genbank = tibble(genbank = unlist(map(str_split(genomes$genbank, \" \"), ~.[[1]][[1]])), seq = str_remove_all(genomes$genbank, \"CM\\\\d+.\\\\d+ Homo sapiens chromosome |J\\\\d+.\\\\d+ Homo sapiens|, GRCh38 reference primary assembly|, complete genome\")) ) cleanup_genomes_df = function(df){ df %>% mutate(seq = ifelse(str_detect(seq, \"mitochondrion|MT\"), \"M\", seq)) } genomes_df_list = map(genomes_df_list, cleanup_genomes_df) chr_map = genomes_df_list %>% reduce(left_join) %>% select(-seq)","title":"Create chromosome name mappings"},{"location":"macs_style/annotate/","text":"This module annotates peaks frames. annotate_peaks_frame ( peaks_frame , refGene_filename ) This function annotates peaks using pybedtools :param peaks_frame: :param refGene_filename: refGene_filename = '/scratch/ref/rmlab/calling_card_ref/mouse/refGene.mm10.Sorted.bed' Source code in callingcardstools/macs_style/annotate.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def annotate_peaks_frame ( peaks_frame , refGene_filename ): \"\"\"This function annotates peaks using pybedtools :param peaks_frame: :param refGene_filename: refGene_filename = '/scratch/ref/rmlab/calling_card_ref/mouse/refGene.mm10.Sorted.bed' \"\"\" #convert peaks frame to sorted bed temp_filename = \"temp_peaks_\" + str ( random . randint ( 1 , 1000 )) + \".bed\" peaks_frame_to_bed ( peaks_frame , temp_filename ) peaks_bed = bt . BedTool ( temp_filename ) peaks_bed = peaks_bed . sort () peaks_bed = peaks_bed . closest ( refGene_filename , D = \"ref\" , t = \"first\" , k = 2 ) peaks_bed . saveas ( temp_filename ) #read in gene_annotation_bedfilename temp_annotated_peaks_columns = [ \"Chr\" , \"Start\" , \"End\" , \"Feature Chr\" , \"Feature Start\" , \"Feature End\" , \"Feature sName\" , \"Feature Name\" , \"Strand\" , \"Distance\" ] temp_annotated_peaks = pd . read_csv ( temp_filename , sep = \" \\t \" , names = temp_annotated_peaks_columns ) # convert start coords back to 1 indexed coordinates temp_annotated_peaks . loc [:, \"Start\" ] = temp_annotated_peaks [ \"Start\" ] + 1 index_list = [( x , y , z ) for x , y , z in zip ( temp_annotated_peaks [ \"Chr\" ], temp_annotated_peaks [ \"Start\" ], temp_annotated_peaks [ \"End\" ])] try : temp_annotated_peaks . index = pd . MultiIndex . from_tuples ( index_list ) except TypeError as e : print ( 'Error at line 72: %s ' % e ) index_list = [( x , y , z ) for x , y , z in zip ( peaks_frame [ \"Chr\" ], peaks_frame [ \"Start\" ], peaks_frame [ \"End\" ])] try : peaks_frame . index = pd . MultiIndex . from_tuples ( index_list ) except TypeError as e : print ( 'Error at line 80: %s ' % e ) try : peaks_frame = peaks_frame . sortlevel ( 0 , axis = 1 ) except AttributeError as e : print ( 'Error at line 85: %s ' % e ) if \"Background Hops\" in peaks_frame . columns : temp_list = [ \"Chr\" , \"Start\" , \"End\" , \"Center\" , \"Experiment Hops\" , \"Fraction Experiment\" , \"TPH Experiment\" , \"Background Hops\" , \"Fraction Background\" , \"TPH Background\" , \"TPH Background subtracted\" , \"Poisson pvalue\" , \"Lambda\" , \"Lambda Type\" , \"Feature 1 sName\" , \"Feature 1 Name\" , \"Feature 1 Start\" , \"Feature 1 End\" , \"Feature 1 Strand\" , \"Feature 1 Distance\" , \"Feature 2 sName\" , \"Feature 2 Name\" , \"Feature 2 Start\" , \"Feature 2 End\" , \"Feature 2 Strand\" , \"Feature 2 Distance\" ] else : temp_list = [ \"Chr\" , \"Start\" , \"End\" , \"Center\" , \"Experiment Hops\" , \"Fraction Experiment\" , \"TPH Experiment\" , \"Poisson pvalue\" , \"Lambda\" , \"Lambda Type\" , \"Feature 1 sName\" , \"Feature 1 Name\" , \"Feature 1 Start\" , \"Feature 1 End\" , \"Feature 1 Strand\" , \"Feature 1 Distance\" , \"Feature 2 sName\" , \"Feature 2 Name\" , \"Feature 2 Start\" , \"Feature 2 End\" , \"Feature 2 Strand\" , \"Feature 2 Distance\" ] peaks_frame = peaks_frame . reindex ( columns = temp_list , fill_value = 0 ) for idx , row in temp_annotated_peaks . iterrows (): if not ( peaks_frame . loc [ idx , \"Feature 1 sName\" ]): peaks_frame . loc [ idx ,[ \"Feature 1 sName\" , \"Feature 1 Name\" , \"Feature 1 Start\" , \"Feature 1 End\" , \"Feature 1 Strand\" , \"Feature 1 Distance\" ]] = \\ list ( row [[ \"Feature sName\" , \"Feature Name\" , \"Feature Start\" , \"Feature End\" , \"Strand\" , \"Distance\" ]]) else : peaks_frame . loc [ idx ,[ \"Feature 2 sName\" , \"Feature 2 Name\" , \"Feature 2 Start\" , \"Feature 2 End\" , \"Feature 2 Strand\" , \"Feature 2 Distance\" ]] = \\ list ( row [[ \"Feature sName\" , \"Feature Name\" , \"Feature Start\" , \"Feature End\" , \"Strand\" , \"Distance\" ]]) return peaks_frame make_peaksbed ( peaks_frame ) This function converts peaks from to a bed file that can be used to display the peak locations on the EPCC browser. The minimum column requirement for the peaks frame is [Chr,Start,End]. This function will return a bed frame with the following columns: [Chr in mm10 or hg19 format,Start,End,name,score] Source code in callingcardstools/macs_style/annotate.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def make_peaksbed ( peaks_frame ): \"\"\"This function converts peaks from to a bed file that can be used to display the peak locations on the EPCC browser. The minimum column requirement for the peaks frame is [Chr,Start,End]. This function will return a bed frame with the following columns: [Chr in mm10 or hg19 format,Start,End,name,score] \"\"\" # TODO resolve this: Do I need to subtract 1 from start?? # ^^ that is in current codebase (not a comment from NF development 20220708) bed_frame = peaks_frame [[ \"Chr\" , \"Start\" , \"End\" ]] . copy () score_list = [ 1000 ] * len ( peaks_frame ) bed_frame [ \"Score\" ] = score_list # generate a list of chromosomes 1-22 (note that python is [start,end) ) and # the sex chromosomes chrlist = [ \"chr\" + str ( x ) for x in range ( 1 , 23 )] + [ \"chrX\" , \"chrY\" ] bed_frame [ \"Chr\" ] = pd . Categorical ( bed_frame [ \"Chr\" ], chrlist ) bed_frame = bed_frame . sort_values ([ 'Chr' , 'Start' , 'End' ]) return bed_frame peaks_frame_to_bed ( peaks_frame , bedfilename ) bladdity blah Parameters: Name Type Description Default peaks_frame DataFrame description required bedfilename Str description required Source code in callingcardstools/macs_style/annotate.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def peaks_frame_to_bed ( peaks_frame , bedfilename ): \"\"\"bladdity blah Args: peaks_frame (DataFrame): _description_ bedfilename (Str): _description_ \"\"\" bed_frame = peaks_frame [[ \"Chr\" , \"Start\" , \"End\" ]] . copy () #start coords of bed files are 0 indexed while ends are 1 indexed # TODO The above comment was in the codebase. # This needs to be checked. General note: +/- should be handled once, # somewhere obvious, preferrably. 20220708 bed_frame . loc [:, \"Start\" ] = bed_frame [ \"Start\" ] - 1 bed_frame . to_csv ( bedfilename , sep = \" \\t \" , header = None , index = None )","title":"Annotate"},{"location":"macs_style/annotate/#callingcardstools.macs_style.annotate.annotate_peaks_frame","text":"This function annotates peaks using pybedtools :param peaks_frame: :param refGene_filename: refGene_filename = '/scratch/ref/rmlab/calling_card_ref/mouse/refGene.mm10.Sorted.bed' Source code in callingcardstools/macs_style/annotate.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def annotate_peaks_frame ( peaks_frame , refGene_filename ): \"\"\"This function annotates peaks using pybedtools :param peaks_frame: :param refGene_filename: refGene_filename = '/scratch/ref/rmlab/calling_card_ref/mouse/refGene.mm10.Sorted.bed' \"\"\" #convert peaks frame to sorted bed temp_filename = \"temp_peaks_\" + str ( random . randint ( 1 , 1000 )) + \".bed\" peaks_frame_to_bed ( peaks_frame , temp_filename ) peaks_bed = bt . BedTool ( temp_filename ) peaks_bed = peaks_bed . sort () peaks_bed = peaks_bed . closest ( refGene_filename , D = \"ref\" , t = \"first\" , k = 2 ) peaks_bed . saveas ( temp_filename ) #read in gene_annotation_bedfilename temp_annotated_peaks_columns = [ \"Chr\" , \"Start\" , \"End\" , \"Feature Chr\" , \"Feature Start\" , \"Feature End\" , \"Feature sName\" , \"Feature Name\" , \"Strand\" , \"Distance\" ] temp_annotated_peaks = pd . read_csv ( temp_filename , sep = \" \\t \" , names = temp_annotated_peaks_columns ) # convert start coords back to 1 indexed coordinates temp_annotated_peaks . loc [:, \"Start\" ] = temp_annotated_peaks [ \"Start\" ] + 1 index_list = [( x , y , z ) for x , y , z in zip ( temp_annotated_peaks [ \"Chr\" ], temp_annotated_peaks [ \"Start\" ], temp_annotated_peaks [ \"End\" ])] try : temp_annotated_peaks . index = pd . MultiIndex . from_tuples ( index_list ) except TypeError as e : print ( 'Error at line 72: %s ' % e ) index_list = [( x , y , z ) for x , y , z in zip ( peaks_frame [ \"Chr\" ], peaks_frame [ \"Start\" ], peaks_frame [ \"End\" ])] try : peaks_frame . index = pd . MultiIndex . from_tuples ( index_list ) except TypeError as e : print ( 'Error at line 80: %s ' % e ) try : peaks_frame = peaks_frame . sortlevel ( 0 , axis = 1 ) except AttributeError as e : print ( 'Error at line 85: %s ' % e ) if \"Background Hops\" in peaks_frame . columns : temp_list = [ \"Chr\" , \"Start\" , \"End\" , \"Center\" , \"Experiment Hops\" , \"Fraction Experiment\" , \"TPH Experiment\" , \"Background Hops\" , \"Fraction Background\" , \"TPH Background\" , \"TPH Background subtracted\" , \"Poisson pvalue\" , \"Lambda\" , \"Lambda Type\" , \"Feature 1 sName\" , \"Feature 1 Name\" , \"Feature 1 Start\" , \"Feature 1 End\" , \"Feature 1 Strand\" , \"Feature 1 Distance\" , \"Feature 2 sName\" , \"Feature 2 Name\" , \"Feature 2 Start\" , \"Feature 2 End\" , \"Feature 2 Strand\" , \"Feature 2 Distance\" ] else : temp_list = [ \"Chr\" , \"Start\" , \"End\" , \"Center\" , \"Experiment Hops\" , \"Fraction Experiment\" , \"TPH Experiment\" , \"Poisson pvalue\" , \"Lambda\" , \"Lambda Type\" , \"Feature 1 sName\" , \"Feature 1 Name\" , \"Feature 1 Start\" , \"Feature 1 End\" , \"Feature 1 Strand\" , \"Feature 1 Distance\" , \"Feature 2 sName\" , \"Feature 2 Name\" , \"Feature 2 Start\" , \"Feature 2 End\" , \"Feature 2 Strand\" , \"Feature 2 Distance\" ] peaks_frame = peaks_frame . reindex ( columns = temp_list , fill_value = 0 ) for idx , row in temp_annotated_peaks . iterrows (): if not ( peaks_frame . loc [ idx , \"Feature 1 sName\" ]): peaks_frame . loc [ idx ,[ \"Feature 1 sName\" , \"Feature 1 Name\" , \"Feature 1 Start\" , \"Feature 1 End\" , \"Feature 1 Strand\" , \"Feature 1 Distance\" ]] = \\ list ( row [[ \"Feature sName\" , \"Feature Name\" , \"Feature Start\" , \"Feature End\" , \"Strand\" , \"Distance\" ]]) else : peaks_frame . loc [ idx ,[ \"Feature 2 sName\" , \"Feature 2 Name\" , \"Feature 2 Start\" , \"Feature 2 End\" , \"Feature 2 Strand\" , \"Feature 2 Distance\" ]] = \\ list ( row [[ \"Feature sName\" , \"Feature Name\" , \"Feature Start\" , \"Feature End\" , \"Strand\" , \"Distance\" ]]) return peaks_frame","title":"annotate_peaks_frame()"},{"location":"macs_style/annotate/#callingcardstools.macs_style.annotate.make_peaksbed","text":"This function converts peaks from to a bed file that can be used to display the peak locations on the EPCC browser. The minimum column requirement for the peaks frame is [Chr,Start,End]. This function will return a bed frame with the following columns: [Chr in mm10 or hg19 format,Start,End,name,score] Source code in callingcardstools/macs_style/annotate.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def make_peaksbed ( peaks_frame ): \"\"\"This function converts peaks from to a bed file that can be used to display the peak locations on the EPCC browser. The minimum column requirement for the peaks frame is [Chr,Start,End]. This function will return a bed frame with the following columns: [Chr in mm10 or hg19 format,Start,End,name,score] \"\"\" # TODO resolve this: Do I need to subtract 1 from start?? # ^^ that is in current codebase (not a comment from NF development 20220708) bed_frame = peaks_frame [[ \"Chr\" , \"Start\" , \"End\" ]] . copy () score_list = [ 1000 ] * len ( peaks_frame ) bed_frame [ \"Score\" ] = score_list # generate a list of chromosomes 1-22 (note that python is [start,end) ) and # the sex chromosomes chrlist = [ \"chr\" + str ( x ) for x in range ( 1 , 23 )] + [ \"chrX\" , \"chrY\" ] bed_frame [ \"Chr\" ] = pd . Categorical ( bed_frame [ \"Chr\" ], chrlist ) bed_frame = bed_frame . sort_values ([ 'Chr' , 'Start' , 'End' ]) return bed_frame","title":"make_peaksbed()"},{"location":"macs_style/annotate/#callingcardstools.macs_style.annotate.peaks_frame_to_bed","text":"bladdity blah Parameters: Name Type Description Default peaks_frame DataFrame description required bedfilename Str description required Source code in callingcardstools/macs_style/annotate.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def peaks_frame_to_bed ( peaks_frame , bedfilename ): \"\"\"bladdity blah Args: peaks_frame (DataFrame): _description_ bedfilename (Str): _description_ \"\"\" bed_frame = peaks_frame [[ \"Chr\" , \"Start\" , \"End\" ]] . copy () #start coords of bed files are 0 indexed while ends are 1 indexed # TODO The above comment was in the codebase. # This needs to be checked. General note: +/- should be handled once, # somewhere obvious, preferrably. 20220708 bed_frame . loc [:, \"Start\" ] = bed_frame [ \"Start\" ] - 1 bed_frame . to_csv ( bedfilename , sep = \" \\t \" , header = None , index = None )","title":"peaks_frame_to_bed()"},{"location":"macs_style/with_background/","text":"","title":"With background"},{"location":"user-guide/getting-started/","text":"","title":"Getting started"}]}